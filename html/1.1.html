<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../css/index.css">
</head>

<body>
   <nav>
      <div class="flex-between">
          <button class="menuBtn" onclick="menu()">Menu</button>
          <b>Values , Tokens and Operators</b>
      </div> 
   </nav>

    <main>

        <aside class="menu">
            <button class="li"> Language <b>+</b> </button>
            <div class="language">
            </div>
            <button class="li"> Browser <b>+</b> </button>
            <div class="browser">
                <h4>Dom Manupulation</h4>
                <ul>
                    <li>Dom</li>
                    <li>Elements</li>
                    <li>Sibling</li>
                    <li>Nodes</li>
                    <li>Ajax</li>
                </ul>
            </div>
            <button class="li"> Beyond <b>+</b> </button>
            <div class="beyond">
                <ul>
                    <li>Nodejs</li>
                    <li>Intro to server</li>
                    <li>Database</li>
                    <li>debute</li>
                </ul>
            </div>
        </aside>
            <div class="m30">
                <h1>values</h1>
                <p>
                    The JavaScript language provides a number of values. These values are the literals that are assigned
                    to a variable or binding. Values can be of different kinds, such as integer types, character types,
                    boolean types and strings.
                    Though all values
                    are made of bits, they play different roles. Every value has a type that de-
                    termines its role. There are six basic types of values in JavaScript: numbers,
                    strings, Booleans, objects, functions, and undefined values.
                    To create a value, you must merely invoke its name. This is conve-
                    nient. You don’t have to gather building material for your values or pay
                    for them. You just call for one, and woosh, you have it. They are not created
                    from thin air, of course. Every value has to be stored somewhere, and if you
                    want to use a gigantic amount of them at the same time, you might run out
                    of bits. Fortunately, this is a problem only if you need them all simultane-
                    ously. As soon as you no longer use a value, it will dissipate, leaving behind
                    its bits to be recycled as building material for the next generation of values.
                    This chapter introduces the atomic elements of JavaScript programs,
                    that is, the simple value types and the operators that can act on such values
                </p>
                <h1>Numbers</h1>
               <p>
               Values of the number type are, unsurprisingly, numeric values. In a JavaScript
               program, they are written as follows
				<li> 13 </li>
				Use that in a program, and it will cause the bit pattern for the number
13 to come into existence inside the computer’s memory.
JavaScript uses a fixed number of bits, namely 64 of them, to store a
single number value. There are only so many patterns you can make with
64 bits, which means that the amount of different numbers that can be rep-
resented is limited. For N decimal digits, the amount of numbers that can
be represented is 10 N . Similarly, given 64 binary digits, you can represent2 64 different numbers, which is about 18 quintillion (an 18 with 18 zeros
after it). This is a lot.
Computer memory used to be a lot smaller, and people tended to use
groups of 8 or 16 bits to represent their numbers. It was easy to acciden-
tally overflow such small numbers—to end up with a number that did not fit
into the given amount of bits. Today, even personal computers have plenty
of memory, so you are free to use 64-bit chunks, which means you need to
worry about overflow only when dealing with truly astronomical numbers.
Not all whole numbers below 18 quintillion fit in a JavaScript number,
though. Those bits also store negative numbers, so one bit indicates the sign
of the number. A bigger issue is that nonwhole numbers must also be repre-
sented. To do this, some of the bits are used to store the position of the deci-
mal point. The actual maximum whole number that can be stored is more in
the range of 9 quadrillion (15 zeros), which is still plenty huge.
<br>
That is 2.998 × 10 8 = 299,800,000.
Calculations with whole numbers (also called integers) smaller than the
aforementioned 9 quadrillion are guaranteed to always be precise. Unfortu-
nately, calculations with fractional numbers are generally not. Just as π (pi)
cannot be precisely expressed by a finite number of decimal digits, many
numbers lose some precision when only 64 bits are available to store them.
This is a shame, but it causes practical problems only in specific situations.
The important thing is to be aware of it and treat fractional digital numbers
as approximations, not as precise values.
               </p>
               <h1>string</h1>
               <p>The next basic data type is the string. Strings are used to represent text. They
                are written by enclosing their content in quotes.
                "Patch my boat with chewing gum"
                'Monkeys wave goodbye'
                Both single and double quotes can be used to mark strings as long as the
                quotes at the start and the end of the string match.
                Almost anything can be put between quotes, and JavaScript will make a
                string value out of it. But a few characters are more difficult. You can imag-
                ine how putting quotes between quotes might be hard. Newlines (the char-
                acters you get when you press ENTER ) also can’t be put between quotes. The
                string has to stay on a single line.
                To include such characters in a string, the following notation is used:
whenever a backslash ( \ ) is found inside quoted text, it indicates that the
character after it has a special meaning. This is called escaping the charac-
ter. A quote that is preceded by a backslash will not end the string but be
part of it. When an n character occurs after a backslash, it is interpreted as
a newline
Strings cannot be divided, multiplied, or subtracted, but the + operator
can be used on them. It does not add, but rather concatenates—it glues two
strings together. The following line will produce the string "concatenate" :
"con" + "cat" + "e" + "nate"
            </p>

               <h1>Unary Operators</h1>
               <p>
               Not all operators are symbols. Some are written as words. One example is
               the typeof operator, which produces a string value naming the type of the
               value you give it.
               <br>
               console.log(typeof 4.5)
               <br>
               // . number
               <br>
               console.log(typeof "x")
               <br>
               // . string
               <br>
               We will use console.log in example code to indicate that we want to see
               the result of evaluating something. When you run such code, the value pro-
               duced should be shown on the screen, though how it appears will depend
               on the JavaScript environment you use to run it.
               The other operators we saw all operated on two values, but typeof takes
               only one. Operators that use two values are called binary operators, while
               those that take one are called unary operators. The minus operator can be
               used both as a binary operator and as a unary operator.
               <br>
               console.log(- (10 - 2))
               <br>
               // . -8
               <br>
               </p>

               <h1>boolean</h1>
               <p>Often, you will need a value that simply distinguishes between two possibil-
                ities, like “yes” and “no” or “on” and “off.” For this, JavaScript has a Boolean
                type, which has just two values: true and false (which are written simply as
                those words).
                Comparisons
                Here is one way to produce Boolean values:
                <br>
                console.log(3 > 2)
                <br>
                // . true
                <br>
                console.log(3 < 2)
                <br>
                // . false
                <br>
                The > and < signs are the traditional symbols for “is greater than” and “is
                less than,” respectively. They are binary operators. Applying them results in
                a Boolean value that indicates whether they hold true in this case.
                Strings can be compared in the same way.
                <br>
                console.log("Aardvark" < "Zoroaster")
                <br>
                // . true
                The way strings are ordered is more or less alphabetic: uppercase letters
                are always “less” than lowercase ones, so "Z" < "a" is true, and nonalphabetic
                <br>
                characters (!, -, and so on) are also included in the ordering. The actual
                comparison is based on the Unicode standard. This standard assigns a num-
                ber to virtually every character you would ever need, including characters
                from Greek, Arabic, Japanese, Tamil, and so on. Having such numbers is
                useful for storing strings inside a computer because it makes it possible to
                represent them as a sequence of numbers. When comparing strings, Java-
                Script goes over them from left to right, comparing the numeric codes of
                the characters one by one</p>


               <h1>Automatic Type Conversion</h1>
               <p>
               In the introduction, I mentioned that JavaScript goes out of its way to accept
               almost any program you give it, even programs that do odd things. This is
               nicely demonstrated by the following expressions:
               <br>
               console.log(8 * null)
               <br>
               // . 0
               <br>
               console.log("5" - 1)
               <br>
               // . 4
               <br>
               console.log("5" + 1)
               <br>
               // . 51
               <br>
               console.log("five" * 2)
               <br>
               // . NaN
               <br>
               console.log(false == 0)
               <br>
               // . true
               <br>
               When an operator is applied to the “wrong” type of value, JavaScript will
               quietly convert that value to the type it wants, using a set of rules that often
               aren’t what you want or expect. This is called type coercion. So the null in the
               first expression becomes 0 , and the "5" in the second expression becomes 5
               (from string to number). Yet in the third expression, + tries string concate-
               nation before numeric addition, so the 1 is converted to "1" (from number
               to string).
               <br>
               When something that doesn’t map to a number in an obvious way (such
               as "five" or undefined ) is converted to a number, the value NaN is produced.
               Further arithmetic operations on NaN keep producing NaN , so if you find your-
               self getting one of those in an unexpected place, look for accidental type
               conversions.
               <br>
               When comparing values of the same type using == , the outcome is easy
               to predict: you should get true when both values are the same, except in
               the case of NaN . But when the types differ, JavaScript uses a complicated and
               confusing set of rules to determine what to do. In most cases, it just tries to
               convert one of the values to the other value’s type. However, when null or
               undefined occurs on either side of th
               </p>
               <h1>chapter summary</h1>
               <p>We looked at four types of JavaScript values in this chapter: numbers, strings,
                Booleans, and undefined values.
                Such values are created by typing in their name ( true , null ) or value ( 13 ,
                "abc" ). You can combine and transform values with operators. We saw binary
                operators for arithmetic ( + , - , * , / , and % ), string concatenation ( + ), compar-
                ison ( == , != , === , !== , < , > , <= , >= ), and logic ( && , || ), as well as several unary
                operators ( - to negate a number, ! to negate logically, and typeof to find a
                value’s type).
                This gives you enough information to use JavaScript as a pocket calcula-
                tor, but not much more. The next chapter will start tying these expressions
                together into basic programs.</p>
            </div>
        </div>
    </main>
</body>
<script src="../js/menuData.js"></script>
<script src="../js/menu.js"></script>
<script src="../js/1.1.js"></script>

</html>
